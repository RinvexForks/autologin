<?php namespace Studious\Autologin;

use Carbon\Carbon;
use DB;
use Illuminate\Auth\UserInterface;
use Illuminate\Config\Repository;
use Illuminate\Routing\UrlGenerator;
use Illuminate\Support\Str;

class Autologin
{
	/**
	 * Illuminate generator instance.
	 *
	 * @var \Illuminate\Routing\UrlGenerator
	 */
	protected $generator;

	/**
	 * Illuminate config repository instance.
	 *
	 * @var \Illuminate\Config\Repository
	 */
	protected $config;

	/**
	 * Create a new Autologin instance.
	 *
	 * @param  \Illuminate\Routing\UrlGenerator
	 * @return void
	 */
	public function __construct(Repository $repository, UrlGenerator $generator)
	{
		$this->config = $repository;
		$this->generator = $generator;
	}

	/**
	 * Generate a link that will automatically login a user without a path
	 * which will instead go to the default route definted in the config
	 * file.
	 *
	 * @param  \Illuminate\Auth\UserInterface
	 * @return string
	 */
	public function user(UserInterface $user)
	{
		return $this->getAutologinLink($user);
	}

	/**
	 * Generate a link that will automatically login a user and then redirect 
	 * them to a hard-coded path as generated by the URL
	 * generator.
	 *
	 * @param  \Illuminate\Auth\UserInterface  $user
	 * @param  string  $path
	 * @param  mixed  $extra
	 * @param  bool  $secure
	 * @return string
	 */
	public function to(UserInterface $user, $path, $extra = array(), $secure = null)
	{
		$path = $this->generator->to($path, $extra, $secure);

		return $this->getAutologinLink($user, $path);
	}

	/**
	 * Generate a link that will automatically login a user and then redirect
	 * them to a named route as generated by the URL generator.
	 *
	 * @param  \Illuminate\Auth\UserInterface  $user
	 * @param  string  $name
	 * @param  mixed  $paramesters
	 * @param  bool  $absolute
	 * @param  \Illuminate\Routing\Route  $route
	 * @return string
	 */
	public function route(UserInterface $user, $name, $parameters = array(), $absolute = true, $route = null)
	{
		$path = $this->generator->route($name, $parameters, $absolute, $route);

		return $this->getAutologinLink($user, $path);
	}

	/**
	 * Validate a token from storage and return an array containing a user
	 * ID and the intended path for the token.
	 *
	 * @param  string  $token
	 * @return mixed
	 */
	public function validate($token)
	{
		$autologinToken = DB::table('autologin_tokens')
			->where('token', $token)
			->first();

		// If we are supposed to remove expired tokens, let's do it now.
		if ($this->config->get('autologin::remove_expired'))
		{
			$this->destroyExpiredTokens();
		}

		return $autologinToken ? [$autologinToken->user_id, $autologinToken->path] : null;
	}

	/**
	 * Get the link that can be used to automatically login a user to the 
	 * application.
	 *
	 * @param  \Illuminate\Auth\UserInterface  $user
	 * @param  string  $path
	 * @return string
	 */
	protected function getAutologinLink(UserInterface $user, $path = null)
	{
		// Get the user ID to be associated with a token.
		$userId = $user->getAuthIdentifier();

		// Generate a random unique token that can be used for the link.
		$token = $this->getAutologinToken();

		// Save the token to storage.
		DB::table('autologin_tokens')->insert([
			'user_id'    => $userId,
			'token'      => $token,
			'path'       => $path,
			'created_at' => Carbon::now(),
			'updated_at' => Carbon::now()
		]);

		// Return a link using the route from the configuration file and
		// the generated token.
		$routeName = $this->config->get('autologin::name');
		
		return $this->generator->route($routeName, $token);
	}

	/**
	 * Generate a random unique token using the length that is provided
	 * in the configuration file.
	 *
	 * @return string
	 */
	protected function getAutologinToken()
	{
		$length = $this->config->get('autologin::length');

		return Str::random($length);
	}

	/**
	 * Remove tokens that have expired from storage.
	 *
	 * @return bool
	 */
	protected function destroyExpiredTokens()
	{
		$lifetime = $this->config->get('autologin::lifetime');

		return (bool) DB::table('autologin_tokens')
			->where('created_at', '<=', Carbon::now()->subMinutes($lifetime))
			->delete();
	}
}
